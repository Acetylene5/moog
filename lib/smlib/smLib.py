# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.31
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""

Low-level bindings for SM; you should be importing sm not smLib

"""

import _smLib
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types



def box(*args):
  """box(int ?=1, int ?=2, int ?=0, int ?=0)"""
  return _smLib.box(*args)

def axis(*args):
  """
    axis(REAL small, REAL big, int ilabel, int iclock, char labels=None, 
        double a1=0.0, double a2=0.0, int ax=-1, 
        int ay=-1, int alen=-1)

    Makes an axis labeled from a1 to a2 at location ax, ay, of length alen.
    The first two arguments specify where you want small and big ticks;
    the fifth argument labels (if present) is a list of strings that will be used to label the big ticks.

    Argument ilabel is 0 for no labels, 1 for labels parallel to axis, 2 for
    perpendicular to axis, and 3 for neither labels nor ticks.
    					    
    Use angle() to determine the angle of the axis.

    Argument iclock is used for (too) many purposes; it iss treated as three
    integers of 1, 2, and 1 bits respectively.

    ICLOCK      & 0x1:      Control the ticks orientation:
                            0       Anticlockwise from the axis
                            1       Clockwise from the axis
    (ICLOCK>>1) & 0x3:      Control the tick direction:
                            0       Ticks are perpendicular to axis
                            1       Ticks are vertical
                            2       Ticks are vertical
                            3       Do not draw any ticks
    (ICLOCK>>3) & 0x1:      Control which side of the axis the ticks appear:
                            0       The same size as the labels
                            1       The opposite side to the labels

    """
  return _smLib.axis(*args)

def device(*args):
  """device(char device) -> int"""
  return _smLib.device(*args)

def defvar(*args):
  """defvar(char variable, char value)"""
  return _smLib.defvar(*args)
defvar("TeX_strings", "1")


def location(*args):
  """location(int x0=3500, int x1=31000, int x1=3500, int y1=31000)"""
  return _smLib.location(*args)

def graphics(*args):
  """graphics()"""
  return _smLib.graphics(*args)

def window(*args):
  """
    window(int nx=1, int ny=1, int kx=1, int ky=1, int kx=-1, 
        int ky=-1)

    Subdivide plotting window into NXxNY regions, and choose the (KX, KY)th (1 <= KZ <= NZ)
    If KZ2 is >= 0, use the regions from KX ... KX2

    """
  return _smLib.window(*args)

def limits(*args):
  """limits(double ?, double ?, double ?, double ?)"""
  return _smLib.limits(*args)

def ticksize(*args):
  """ticksize(double ?, double ?, double ?, double ?)"""
  return _smLib.ticksize(*args)

def notation(*args):
  """
    notation(double xmin=0, double xmax=0, double ymin=0, double ymax=0)

    Use exponential notation when labelling axis points outside the specified range.
    notation() resets the default.

    """
  return _smLib.notation(*args)

def expand(*args):
  """expand(double expand=1)"""
  return _smLib.expand(*args)

def gflush(*args):
  """gflush()"""
  return _smLib.gflush(*args)

def cursor(*args):
  """
    cursor()

    Pop up the cursor, wait for a keypress, and return the list (x, y, key)

    """
  return _smLib.cursor(*args)

def erase(*args):
  """erase()"""
  return _smLib.erase(*args)

def page(*args):
  """page()"""
  return _smLib.page(*args)

def angle(*args):
  """angle(double ?=0)"""
  return _smLib.angle(*args)

def ptype(*args):
  """
    ptype(ptype = [41])

    Set the point type to the specified list or array

    Ptype ns causes points to be drawn as n sided polygons of a style s,
    re s refers to:
         0 = open 
         1 = skeletal (center connected to vertices)
         2 = starred
         3 = solid

    For example, ptype([11]) makes points appear as dots, ptype([41]) makes
    agonal) crosses, and ptype([63]) makes filled hexagons. Points made
    of lines (types 0, 1, and 2) are drawn using the current LTYPE.

    """
  return _smLib.ptype(*args)

def points(*args):
  """points(REAL ?, REAL ?)"""
  return _smLib.points(*args)

def histogram(*args):
  """histogram(REAL ?, REAL ?)"""
  return _smLib.histogram(*args)

def connect(*args):
  """connect(REAL ?, REAL ?)"""
  return _smLib.connect(*args)

def points_if(*args):
  """points_if(REAL ?, REAL ?, REAL ?)"""
  return _smLib.points_if(*args)

def histogram_if(*args):
  """histogram_if(REAL ?, REAL ?, REAL ?)"""
  return _smLib.histogram_if(*args)

def connect_if(*args):
  """connect_if(REAL ?, REAL ?, REAL ?)"""
  return _smLib.connect_if(*args)

def lweight(*args):
  """
    lweight(double ?=1)

    Make all lines in the plot darker (1 or less: normal)

    """
  return _smLib.lweight(*args)

def identification(*args):
  """
    identification(char idStr)

    Add an identification string to a plot

    """
  return _smLib.identification(*args)

def xlabel(*args):
  """
    xlabel(char lab)

    Write a label below the x-axis

    """
  return _smLib.xlabel(*args)

def ylabel(*args):
  """
    ylabel(char lab)

    Write a label to the left of the y-axis

    """
  return _smLib.ylabel(*args)

def errorbar(*args):
  """errorbar(REAL ?, REAL ?, REAL ?, int ?)"""
  return _smLib.errorbar(*args)

def ltype(*args):
  """
    ltype(int ltype=0)

    Set the current linetype:
         0 = solid
         1 = dot
         2 = short dash
         3 = long dash
         4 = dot - short dash
         5 = dot - long dash
         6 = short dash - long dash
         10= erase lines   

    """
  return _smLib.ltype(*args)

def relocate(*args):
  """
    relocate(double x, double y)

    Move the plot pointer to (x, y)

    """
  return _smLib.relocate(*args)

def label(*args):
  """
    label(char str)

    Draw a label at the current plotting point (may be set using relocate)

    """
  return _smLib.label(*args)

def dot(*args):
  """
    dot()

    Draw a point at the current plotting point (may be set using relocate)

    """
  return _smLib.dot(*args)

def draw(*args):
  """draw(double x, double y)"""
  return _smLib.draw(*args)

def putlabel(*args):
  """
    putlabel(int where, char str)

    Write str onto the plot near the current plotting point (may be set using relocate).
     parameter where specifies the location of the string:
                label to left     centre     right
         label above      7         8         9 
               centered   4         5         6
               below      1         2         3

    """
  return _smLib.putlabel(*args)

def grid(*args):
  """
    grid(int major_minor=0, int xy=3)

    Draw a grid at major (major_minor = 0) or minor ( == 1)
    xy is 1 draw only an x-grid; if 2 draw only a y-grid; if 3 (or 0) draw both

    """
  return _smLib.grid(*args)

def ctype_i(*args):
  """ctype_i(int ?=0)"""
  return _smLib.ctype_i(*args)

def ctype(*args):
  """ctype(char ?="default")"""
  return _smLib.ctype(*args)

def add_ctype(*args):
  """add_ctype(char name, int red, int green, int blue) -> int"""
  return _smLib.add_ctype(*args)

def delete_ctype(*args):
  """delete_ctype(char name) -> int"""
  return _smLib.delete_ctype(*args)

def redraw(*args):
  """redraw(int ?)"""
  return _smLib.redraw(*args)

def hardcopy(*args):
  """hardcopy()"""
  return _smLib.hardcopy(*args)

def levels(*args):
  """
    levels(REAL ?)

    Set the contour levels for contour()

    """
  return _smLib.levels(*args)

def contour(*args):
  """
    contour(pyArray, x1=0, x2=nx-1, y1=0, y2=nx-1)

    Make a contour plot of pyArray, using contour levels set by levels()

    If x1/x2 or y1/y2 are set, they are taken to be the x and y ranges
    of the array (default: 0..N-1)

    """
  return _smLib.contour(*args)

def shade(*args):
  """shade(float ?, REAL ?, REAL ?)"""
  return _smLib.shade(*args)

cvar = _smLib.cvar

